[{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第二篇 基础系统\r","date":"2024-12-22","objectID":"/posts/7b002b3/:1:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第三章 游戏场景的转换——状态模式（State）\r","date":"2024-12-22","objectID":"/posts/7b002b3/:2:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"一、游戏场景\rUnity中使用场景（Scene）作为游戏运行时的环境（该环境意指游戏包含游戏物体游戏资源的环境，而非程序上的环境）。其他多数游戏引擎也有类似的概念。 场景转换 当游戏比较复杂时，通常会设计成多个场景，让玩家在多个场景之间转换。常见的场景设置： 登录场景 主画面场景 战斗场景 …… 场景切分的好处 将不同场景不同功能不同资源明确划分 某些场景可以重复利用 本书范例的场景切分 开始场景（StartScene）：GameLoop游戏对象的所在，游戏启动及相关游戏设置的加载。 主画面场景（MainMenuScene）：显示游戏名称和“开始”按钮。 战斗场景（BattleScene）：游戏主要执行的场景。 场景转换的一般实现 ​ 在一个SceneManager类中一般可以用两个switch语句，一个用于切换场景，一个在Update函数里用于更新游戏逻辑。 ​ 缺点： 增加场景需要在各处（主要是两个switch语句中）增加对应的代码。 每一个与某种场景相关的对象都必须在SceneManager类中持有，此时这些对象同时被所有场景共享（不管它们是否有联系），增加了耦合度，不利于于维护。 ","date":"2024-12-22","objectID":"/posts/7b002b3/:2:1","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"二、状态模式（State）\r让一个对象的行为随着内部状态的改变而变化，而该对象也像是换了类一样。—GoF 状态模式的核心 Context（状态拥有者，状态机）：持有状态对象，并且包含状态转换，状态添加方法等。Context在同一时间只会处于一种状态中。 State（状态基类）：制定状态的接口。 ConcreteState（状态子类）：继承自状态基类，表示一个具体状态。 状态模式实现范例 public class Context { State m_state = null;//当前状态，同一时间只表现为一种状态 public void Request(int Value) {//接收外界参数，进行状态转换 m_State.Handle(Value); } public void SetState(State theState) { Debug.Log(\"Context.SetState:\" + theState); m_state = theState; } } public abstract class State { protected Context m_Context = null; public State(Context theContext) { m_Context = theContext; } public abstract void Handle(int Value);//各种状态的基本行为 } public class ConcreteStateA: State { public ConcreteStateA(Context theContext): base(theContext) { } public override void Handle(int Value) { Debug.Log(\"ConcreteStateA.Handle\"); if (Value \u003e 10) { m_Context.SetState(new ConcreteStateB(m_Context)); } } } public class ConcreteStateB: State { public ConcreteStateB(Context theContext): base(theContext) { } public override void Handle(int Value) { Debug.Log(\"ConcreteStateB.Handle\"); if (Value \u003e 20) { m_Context.SetState(new ConcreteStateC(m_Context)); } } } public class ConcreteStateC: State { public ConcreteStateC(Context theContext): base(theContext) { } public override void Handle(int Value) { Debug.Log(\"ConcreteStateC.Handle\"); if (Value \u003e 30) { m_Context.SetState(new ConcreteStateA(m_Context)); } } } //测试范例 void UnitTest() { Context theContext = new Context(); theContext.SetState(new ConcreteStateA(theContext)); theContext.Request(5); theContext.Request(15); theContext.Request(25); theContext.Request(35); } Context.SetState:DesignPattern_State.ConcreteStateA ConcreteStateA.Handle ConcreteStateA.Handle Context.SetState:DesignPattern_State.ConcreteStateB Context.SetState:DesignPattern_State.ConcreteStateC Context.SetState:DesignPattern_State.ConcreteStateA 除了上述三个元素，状态转换也是重要的一环。主要有两种方式： 交由Context类本身,按条件在各状态之间转换。具体实现需要在Context类里写各个状态类的转换方法。 产生Context类对象时, 马上指定初始状态给Context对象,而在后续执行过程中的状态转换则交由State对象负责,Context对象不再介入。这种方式更自然，多数人也愿意用该种方式。 ","date":"2024-12-22","objectID":"/posts/7b002b3/:2:2","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"三、使用状态模式实现游戏场景的转换\r在U3D中，游戏同一时间只会在一个场景中运行，所以我们可以将不同的场景做成不同的状态类，然后使用一个SceneStateController来控制场景（状态）转换。 具体实现 ISceneState: 场景类的接口, 定义《P级阵地》种场景转换和执行时需要调用的方法 StartState, MainMenuState, BattleState: 分别对应范例中的开始场景(StartScene), 主画面场景(MainMenuScene)及战斗场景(BattleScene),作为这些场景执行时的操作类 SceneStateController: 场景状态的拥有者(Context), 保持当前游戏场景状态, 并作为与GameLoop类互动的接口. 除此之外, 也是执行\"Unity3D场景转换\"的地方 GameLoop:: 游戏主循环类作为Unity3D与《P级阵地》的互动接口,包含了初始化游戏和定期调用更新操作 代码 //ISceneState.cs public class ISceneState { //靠状态名来区分状态 private string m_StateName = \"ISceneState\"; public string StateName { get { return m_StateName; } set { m_StateName = value; } } //持有状态机 protected SceneStateController m_Controller = null; public ISceneState(SceneStateController Controller) { m_Controller = Controller; } //状态开始的行为 public virtual void StateBegin() { } //状态结束的行为 public virtual void StateEnd() { } //状态更新的行为 public virtual void StateUpdate() { } public override string ToString() { return string.Format(\"[I_SceneState: StateName = {0}]\", StateName); } } //StartScene.cs //该类仅作为加载场景出现，所以进入该状态直接加载MainMenuScene场景 public class StartScene: ISceneState { public StartScene(SceneStateController Controller): base(Controller) { this.StateName = \"StartState\"; } public override void StateBegin() { } public override void StateUpdate() { m_Controller.SetState(new MainMenuState(m_Controller), \"MainMenuScene\"); } } //MainMenuState.cs //开始界面，只需注册一个按钮事件用于开始游戏（即转换到战斗场景BattleScene） public class MainMenuState: ISceneState { public MainMenuState(SceneStateController Controller): base(Controller) { this.StateName = \"MainMenuState\"; } public override void StateBegin() { Button tmpBtn = UITool.GetUIComponent\u003cButton\u003e(\"StartGameBtn\"); if (tempBtn != null) { tmpBtn.onClick.AddListener(()=\u003eOnStartGameBtnClick(tmpBtn)); } public void OnStartGameClick(Button theButton) { m_Controller.SetState(new BattleState(m_Controller), \"BattleScene\"); } } //BattleScene.cs //战斗场景，游戏主要玩法逻辑所在 public class BattleScene: ISceneState { public BattleScene(SceneStateController Controller): base(Controller) { this.StateName = \"BattleState\"; } public overrride void StateBegin() { PBaseDefenseGame.Instance.Initial(); } public ovrride void StateEnd() { PBaseDefenseGame.Instance.Update(); } public ovrride void StateUpdate() { InputProcess(); PBaseDefenseGame.Instance.Update(); if (PBaseDefenseGame.Instance.ThisGameIsOver()) { m_Controller.SetState(new MainMenuState(m_Controller), \"MainMenuScene\"); } } private void InputProcess() { //... } } //SceneStateController.cs // public class SceneStateController { private ISceneState m_State; private bool m_bRunBegin = false;//用于标识当前状态的开始行为函数有没有执行，没有执行则需要执行，已经执行过就不需要再执行。 public SceneStateController() { } //设置状态并且转换到对应场景 public void SetState(ISceneState State, string LoadSceneName) { m_bRunBegin = false; LoadScene(LoadSceneName); if (m_State != null) { m_State.StateEnd(); } m_State = State; } private void LoadScene(string LoadSceneName) { if (LoadSceneName == null || LoadSceneName.Length == 0) { return; } Application.LoadLevel(LoadSceneName); } public void StateUpdate() { //场景是否加载完成，如果没加载完就不执行下面的逻辑 if (Application.isLoadingLevel) { return; } if (m_state != null \u0026\u0026 m_bRunBegin == false) { m_State.StateBegin(); m_bRunBegin = true; } if (m_State != null) { m_State.StateUpdate(); } } } //GameLoop.cs //游戏主循环，通过SceneStateController控制游戏进程 public class GameLoop: MonoBehavior { SceneStateController m_SceneStateController = new SceneStateController(); void Awake() { GameObject.DontDestroyOnLoad(this.gameObject); UnityEngine.Random.seed = (int)DateTime.Now.Ticks; } void Start() { m_SceneStateController.SetState(new StartState(m_SceneStateController), \"\"); } void Update() { m_SceneStateController.StateUpdate(); } } ","date":"2024-12-22","objectID":"/posts/7b002b3/:2:3","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"四、总结\r状态模式的优点： 减少错误的发生并降低维护难度 状态执行环境单一化 项目之间可以共享场景 状态模式的缺点： 游戏状态过多时容易“状态爆炸”。 其他应用方式： 角色控制、角色AI。 游戏服务器连线状态。 关卡进行状态。 ","date":"2024-12-22","objectID":"/posts/7b002b3/:2:4","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第一篇 设计模式与游戏设计\r","date":"2024-12-16","objectID":"/posts/d7a0598/:1:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第一章 游戏实践中的设计模式\r","date":"2024-12-16","objectID":"/posts/d7a0598/:2:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"一、定义及常见设计原则\r设计模式（Design Patterns or GoF）定义如下： ​ 每一种模式都在说明某种一再出现的问题，并描述解决方法的核心，之后让你能够据以变化出各种招式，来解决上万个类似的问题。 面向对象设计中常见的设计原则： 单一职责原则（SRP：Single Responsibility Principle） 即“当设计封装一个类时，该类应该只负责一件事情”。 开-闭原则（OCP：Open-Closed Principle） 即一个类应该“对扩展开放，对修改关闭”。对修改关闭即对已经完成某功能的类，不能再修改这个类的任何接口或实现。对扩展开放即对功能的增加保持开放，可以将操作方法向上提升，抽象化为接口，而功能的实现下移到子类，此时功能的增加就可以通过增加子类实现。 里氏替换原则（LSP：Liskov Substitution Principle） 即“子类必须能够替换父类”。 依赖倒置原则（DIP：Dependence Inversi Principle） 高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念。 抽象接口不应该依赖于实现，而实现应该依赖于抽象接口。 即高层模块应定义接口，再由低层模块遵循这个接口实现 接口隔离原则（ISP：Interface Segregation Principle） 即“客户端不应该被迫使用它们用不到的接口方法”。 最少知识原则（LKP：Least Knowledge Principle） 即当设计实现一个类时，这个类越少使用其他类提供的功能越好。 少用继承多用组合 尤其有的时候我们并不想完全实现父类接口的方法，此时应尽可能使用组合设计。 ","date":"2024-12-16","objectID":"/posts/d7a0598/:2:1","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"二、游戏程序设计与设计模式\r游戏程序设计面对的问题; 市场的多样性 需求的多样性 平台的多样性 技术的多样性 GoF的23种设计模式分类： 生成模式（Creational）：产生对象的过程及方式。 结构模式（Structural）：类或对象之间组合的方式。 行为模式（Behavioral）：类或对象之间互动或责任分配的方式。 可能的问题： ​ 过度设计—某些设计直到项目上市都没有被使用过。 ","date":"2024-12-16","objectID":"/posts/d7a0598/:2:2","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第二章 游戏范例说明\r","date":"2024-12-16","objectID":"/posts/d7a0598/:3:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"游戏范例：P级阵地\r该书利用一个完整游戏范例说明如何应用19种设计模式，该范例《P级阵地》简介： “P级阵地是一款阵地防守游戏，任务是不让玩家的阵地被敌方单位。玩家可通过位于地图上的兵营，产生不同的兵种来防守阵地，而这些由兵营产生的玩家作战单位，会在阵地附近留守，过程之中玩家不必操控每一个作战单位，它们会自动发现来袭的敌人并将其击退。敌方单位则是定期有阵地外围不断地朝阵地中央前行，并攻击阻挡在面前的玩家单位，当有3个敌方单位抵达阵地中央，则游戏失败。” 项目地址：sttsai/PBaseDefense_Unity3D ","date":"2024-12-16","objectID":"/posts/d7a0598/:3:1","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"GoF的设计模式范例\r除了一个应用设计模式的游戏范例，本书还提供了一个单独的设计模式练习程序包含在场景DesignPatternExample中。 ","date":"2024-12-16","objectID":"/posts/d7a0598/:3:2","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["博客搭建"],"content":"typora+图床实现处处可用的带图md文档\r","date":"2023-08-11","objectID":"/posts/typora+%E5%9B%BE%E5%BA%8A/:1:0","tags":["博客搭建"],"title":"Typora+图床","uri":"/posts/typora+%E5%9B%BE%E5%BA%8A/"},{"categories":["博客搭建"],"content":"Typora\r一个非常简洁好用的md文档编辑器。官方正版收费，但也不贵，不太差钱的可以直接入。或者可以使用一些“测试版”，网上一搜一大把。 官方中文站：Typora 官方中文站 (typoraio.cn) ","date":"2023-08-11","objectID":"/posts/typora+%E5%9B%BE%E5%BA%8A/:2:0","tags":["博客搭建"],"title":"Typora+图床","uri":"/posts/typora+%E5%9B%BE%E5%BA%8A/"},{"categories":["博客搭建"],"content":"图床\r图床，可以简单理解为一个网络中专门用于存储图片的空间。我们将图片上传，就会得到一个类似于网址的链接，把链接放到文档中便会显示相应的图片，且不受本地限制。 其最经典的应用就是在博客中。如果你不使用图床，那么你直接上传带有图片的md文档，图片是无法被加载的，因为你的图片还在本地。使用图床就可以解决这样的问题。 当然，也可以将你博客当中的图片一并上传至服务器，但是这种方式对于博客这种场景是不如直接使用图床方便的。 ","date":"2023-08-11","objectID":"/posts/typora+%E5%9B%BE%E5%BA%8A/:3:0","tags":["博客搭建"],"title":"Typora+图床","uri":"/posts/typora+%E5%9B%BE%E5%BA%8A/"},{"categories":["博客搭建"],"content":"在Typora中使用图床\r在typora中打开偏好设置中的-图像-，插入图片时选择-上传图片-。这里注意一些旧版本的typora是没有这个选项的，请使用较新的版本。 第一种方式： 在上传服务中选择PicGo(app)，然后点击下载app(比较慢，建议直接搜索picgo下载)，下面的路径只要找到自己安装的picgo.exe的所在路径即可。 先进入smms的官网Home - SM.MS | Dashboard (smms.app)，注册登录后点击API Token，生成Token并复制下来。 进入app，点击图床设置，有几个图床供我们选择，我这里选择的是smms（这个还算是方便好用，别的图床可以自行尝试）。点击加号，配置名随便写（最好是英文），Token就填我们上面复制的那个。备用域名要填smms.app（这步很重要，不填会出错）。 第二种方式： 在上传服务中选择picgo-core，然后点击下载，下载完成后点击打开配置文件，具体配置： { \"picBed\": { \"uploader\": \"smms\", \"smms\": { \"token\": \"你的token\" } }, \"picgoPlugins\": {} } 但是作者并没有配置成功，应该是该配置还需要加上备用域名smms.app。不太推荐该方式，因为该方式不方便管理，且下载奇慢（暂时没找到其他方式下载）。有兴趣的读者可以参照typora文档自行尝试。 点验证图片上传时可能会报错，但不用管，自行复制图片到md文档验证就行。 ","date":"2023-08-11","objectID":"/posts/typora+%E5%9B%BE%E5%BA%8A/:4:0","tags":["博客搭建"],"title":"Typora+图床","uri":"/posts/typora+%E5%9B%BE%E5%BA%8A/"},{"categories":["博客搭建"],"content":"hugo+github搭建个人博客\r非常推荐使用hugo建立自己的个人博客，安装配置都非常简单不容易出错，实乃我等小白福音 ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:1:0","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":["博客搭建"],"content":"搭建工具\r基于go语言的博客框架Hugo Git GitHub或者Gitee ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:2:0","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":["博客搭建"],"content":"搭建流程参考\r该博客搭建基本上是基于下面up的视频，hugo本身并不复杂，up也已经讲的非常好了，所以不多赘述，只贴出相应链接，以及相应的一些心得，具体安装和流程请参考下面视频。 ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:3:0","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":["博客搭建"],"content":"在mac下：\rhttps://www.bilibili.com/video/BV1q4411i7gL up主：CodeSheep 语言简练，非常易懂，整体流程清晰，建议无论是win还是mac都先看此视频。 ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:3:1","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":["博客搭建"],"content":"在win下：\rhttps://www.bilibili.com/video/BV13c411h7k7 up主：祈LHL 讲的非常全面，内容对比上面增加了部署到Gitee，更新文章，谷歌收录等。 ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:3:2","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":["博客搭建"],"content":"博客个性化\r搭建好了博客之后，就要考虑把博客真正变成自己的。通过选择主题，更改主题配置文件，甚至修改样式文件个性化自己的博客。 hugo提供了很多个性化网站主题样式模板，建议先使用NewBee（本站就是使用了该主题）。该主题由国人大佬开发，功能强大且文档非常全面细致，基本你把这个玩转其他的都可以举一反三。 NewBee主题：NewBee | Hugo Themes (gohugo.io) NewBee文档：NewBee (xioyito.top) 另外hugo的主题也切换非常容易，所以如果碰到一些配置困难的主题，稍作尝试不行就换一个主题，不要纠结，一些主题本身确实存在问题。 至此，一个简单且具有个人风格的博客就算是搭建好啦，赶快撰写文档丰富你的个人博客吧！ ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:4:0","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"\r轻易听信别人告诉你的，让禁忌阻碍你的视野，给自己定下条条框框，过约定俗成的生活 ——我把这称作二手人生。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于作者\r一个喜欢编程，游戏的小白，本博客分享一些游戏开发，编程开发路上的所见所得，所思所想。  B站：Cyber蔚蓝的个人空间-Cyber蔚蓝个人主页-哔哩哔哩视频  邮箱：azure1116@qq.com ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于博客\r博客内容主要以游戏开发方向为主，分享交流一些有趣程序、技巧、开发教程、心情和学习记录等。 博客历史\r基于 Hugo + NewBee 主题搭建博客AzureBlog并部署在GitHub Pages。 当时刚刚研二比较闲，只做打发时间，并没有想好具体记录什么内容。\r2023找完工作闲了下来，也意识到自己的很多不足（尤其在游戏开发方面），决定重新出发，深入学习并以博客记录。 并且使用新主题FixIt\r2024-12-17\r","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"}]