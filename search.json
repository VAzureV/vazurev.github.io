[{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第二篇 基础系统\r","date":"2024-12-26","objectID":"/posts/7b4e561/:1:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式","外观模式","Facade"],"title":"设计模式与游戏完美开发(2)","uri":"/posts/7b4e561/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第四章 游戏主要类——外观模式（Facade）\r","date":"2024-12-26","objectID":"/posts/7b4e561/:2:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式","外观模式","Facade"],"title":"设计模式与游戏完美开发(2)","uri":"/posts/7b4e561/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"一、游戏子功能的整合\r一个游戏程序常常由内部数个不同的子系统构成（如事件系统，关卡系统，成就系统等等），这些系统支持着游戏基本功能和玩法。这些子系统需要按照一定的顺序进行初始化，某些条件达成时也需要按照一定的流程替他们释放资源。并且这些子系统会彼此使用对方的功能，即不同子系统之间会进行“通信”。 通常来说，我们认为这些子系统的通信及初始化过程应当发生在“内部”，因为当有其他的程序（或者我们自己）来添加一个游戏功能系统时，最好能不用去了解其他子系统之间的相关运行过程，而仅仅通过一些相对“高级”的接口来调用其他子系统的相关功能。 上一章所提到的\"战斗状态类(BattleScene)“就是一个必须使用到的游戏系统功能的客户端，根据上一章的说明,战斗状态类(BattleState)主要负责游戏战斗的运行,而《P级阵地》在进行一场战斗时,需要大部分的子系统一起合作完成.在实现时,可以先把这些子系统及相关的执行流程全都放在BattleState类之中一起完成。 在战斗系统类中实现所有子系统相关操作： public class BattleState: ISceneState { //声明所有需要的子系统 private GameEventSystem m_GameEventSystem = null; private CampSystem m_CampSystem = null; private StageSystem m_StageSystem = null; private CharacterSystem m_CharacterSystem = null; private APSystem m_ApSystem = null; private AchivementSystem m_AchievementSystem =null; public GameState(SceneStateController Controller): base(Controller) { this.StateName = \"GameState\"; InitGameSystem(); } //初始化这些子系统 private void InitGameSystem() { m_GameEventySystem = new GameEventSystem(); ... } //子系统的更新操作 private void UpdateGameSystem() { m_GameEventSystem.Update(); ... } } 虽然这样的实现方式很简单，但让战斗状态类(BattleState)整个客户端去负责调用所有与游戏玩法相关的系统功能是不好的实现方式，原因是: 从让事情单一化(单一职责原则)这一点来看,BattleScene类负责的是游戏在\"战斗状态\"下的功能执行及状态切换，所以不应该负责游戏子系统的初始化,执行操作及相关的整合工作。 以\"可重用性\"来看,这种设计方式会使得BattleState类不容易转换给其他项目使用，因为BattleState类与太多特定的子系统类产生关联，必须将它们删除才能转换给其他项目,因此丧失可重用性 综合上述两个原因,将这些子系统从BattleState类中移出，整合在单一类之下,会是比较好的做法.所以,在《P级阵地》中应用了外观模式(Facade)来整合这些子系统，使它们成为单一界面并提供外界使用。 ","date":"2024-12-26","objectID":"/posts/7b4e561/:2:1","tags":["书籍阅读","设计模式与游戏完美开发","设计模式","外观模式","Facade"],"title":"设计模式与游戏完美开发(2)","uri":"/posts/7b4e561/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"二、外观模式（Facade）的定义\r“为子系统定义一组统一的接口，这个高级的接口会让子系统更容易被使用”。—GoF 其实,外观模式(Facade)是在生活中最容易碰到的模式。当我们能够利用简单的行为来操作一个复杂的系统时，当下所使用的接口,就是以外观模式(Facade)来定义的高级接口。 外观模式(Facade)的重点在于，它能将系统内部的互动细节隐藏起来，并提供一个简单方便的接口.之后客户端只需要通过这个接口，就可以操作一个复杂系统并让它们顺利运行。 参与者的说明如下: client(客户端,用户)： 从原本需要操作多个子系统的情况,改为只需要面对一个整合后的界面。 subSystem(子系统)： 原本会由不同的客户端(非同一系统相关)来操作,改为只会由内部系统之间交互使用。 Facade(统一对外的界面)： 整合所有子系统的接口及功能,并提供高级界面(或接口)供客户端使用。 接收客户端的信息后,将信息传送给负责的子系统。 ","date":"2024-12-26","objectID":"/posts/7b4e561/:2:2","tags":["书籍阅读","设计模式与游戏完美开发","设计模式","外观模式","Facade"],"title":"设计模式与游戏完美开发(2)","uri":"/posts/7b4e561/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"三、使用外观模式实现游戏主程序\rPBaseGameDefenseGame类就是\"整合所有子系统,并提供高级界面的外观模式类”。 具体实现： //PBaseDefenseGame.cs public class PBaeDefenseGame { //声明各个游戏子系统 ... private GameEventSystem m_GameEventSystem =null; ... //初始化 public void Initinal() { ... m_GameEventSystem = new GameEventSystem(this); ... } //更新操作 public void Update() { ... m_GameEventSystem.Update(); ... } //获取游戏状态、敌人数量等 ... } //BattleState.cs public class BattleState: ISceneState { public override void StateBegin() { PBaseDefenseGame.Instance.Initinal();//初始化，隐藏了其它子系统的细节 } public override void StateEnd() { PBaseDefenseGame.Instance.Release(); } public override void StateUpdate() { ... PBaseDefenseGame.Instance.Update(); ... if (PBaseDefenseGame.Instance.ThisGameIsOver()) { m_Controller.SetState(new MainMenuState(m_Controller), \"MainMenuState\"); } } } 使用外观模式的优点： 使用外观模式(Facade)可将战斗状态类BattleState单一化，让该类只负责游戏在\"战斗状态\"下的功能执行及状态切换，不用负责串接各个游戏系统的初始化和功能调用。 使用外观模式(Facade)使得战斗状态类BattleScene减少了不必要的类引用及功能整合，因此增加了BattleState类被重复使用的机会。 节省时间　Unity3D本身提供了不少系统的Facade接口，例如物理引擎,渲染系统,动作系统,粒子系统等。 易于分工开发　对于一个既庞大又复杂的子系统而言,若应用外观模式(Facade)，即可成为另一个Facade接口.所以，在工作 的分工配合上，开发者只需要了解对方负责系统的Facade接口类，不必深入了解其中的运行方式。 增加系统的安全性 隔离客户端对子系统的接触，除了能减少耦合度之外，安全性也是重点之一。 注意事项： 由于将所有子系统集中在Facade接口类中，最终会导致Facade接口类过于庞大且难以维护，当发生这种情况时,可以重构Facade接口类,将功能相近的子系统进行整合，以减少内部系统的依赖性，或是整合其他设计模式来减少Facade接口类过度膨胀。 Facade面对变化时： 随着开发需求的变更，任何游戏子系统的修改及更换,都被限制在PBaseDefenseGame这个Facade接口类内。所以,，当有新的系统需要增加时，也只会影响PBaseDefenseGame类的定义及增加对外开放的方法，这样就能使项目的变动范围减到最小。 ","date":"2024-12-26","objectID":"/posts/7b4e561/:2:3","tags":["书籍阅读","设计模式与游戏完美开发","设计模式","外观模式","Facade"],"title":"设计模式与游戏完美开发(2)","uri":"/posts/7b4e561/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第二篇 基础系统\r","date":"2024-12-22","objectID":"/posts/7b002b3/:1:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式","状态模式","State"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第三章 游戏场景的转换——状态模式（State）\r","date":"2024-12-22","objectID":"/posts/7b002b3/:2:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式","状态模式","State"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"一、游戏场景\rUnity中使用场景（Scene）作为游戏运行时的环境（该环境意指游戏包含游戏物体游戏资源的环境，而非程序上的环境）。其他多数游戏引擎也有类似的概念。 场景转换 当游戏比较复杂时，通常会设计成多个场景，让玩家在多个场景之间转换。常见的场景设置： 登录场景 主画面场景 战斗场景 …… 场景切分的好处 将不同场景不同功能不同资源明确划分 某些场景可以重复利用 本书范例的场景切分 开始场景（StartScene）：GameLoop游戏对象的所在，游戏启动及相关游戏设置的加载。 主画面场景（MainMenuScene）：显示游戏名称和“开始”按钮。 战斗场景（BattleScene）：游戏主要执行的场景。 场景转换的一般实现 ​ 在一个SceneManager类中一般可以用两个switch语句，一个用于切换场景，一个在Update函数里用于更新游戏逻辑。 ​ 缺点： 增加场景需要在各处（主要是两个switch语句中）增加对应的代码。 每一个与某种场景相关的对象都必须在SceneManager类中持有，此时这些对象同时被所有场景共享（不管它们是否有联系），增加了耦合度，不利于于维护。 ","date":"2024-12-22","objectID":"/posts/7b002b3/:2:1","tags":["书籍阅读","设计模式与游戏完美开发","设计模式","状态模式","State"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"二、状态模式（State）\r让一个对象的行为随着内部状态的改变而变化，而该对象也像是换了类一样。—GoF 状态模式的核心 Context（状态拥有者，状态机）：持有状态对象，并且包含状态转换，状态添加方法等。Context在同一时间只会处于一种状态中。 State（状态基类）：制定状态的接口。 ConcreteState（状态子类）：继承自状态基类，表示一个具体状态。 状态模式实现范例 public class Context { State m_state = null;//当前状态，同一时间只表现为一种状态 public void Request(int Value) {//接收外界参数，进行状态转换 m_State.Handle(Value); } public void SetState(State theState) { Debug.Log(\"Context.SetState:\" + theState); m_state = theState; } } public abstract class State { protected Context m_Context = null; public State(Context theContext) { m_Context = theContext; } public abstract void Handle(int Value);//各种状态的基本行为 } public class ConcreteStateA: State { public ConcreteStateA(Context theContext): base(theContext) { } public override void Handle(int Value) { Debug.Log(\"ConcreteStateA.Handle\"); if (Value \u003e 10) { m_Context.SetState(new ConcreteStateB(m_Context)); } } } public class ConcreteStateB: State { public ConcreteStateB(Context theContext): base(theContext) { } public override void Handle(int Value) { Debug.Log(\"ConcreteStateB.Handle\"); if (Value \u003e 20) { m_Context.SetState(new ConcreteStateC(m_Context)); } } } public class ConcreteStateC: State { public ConcreteStateC(Context theContext): base(theContext) { } public override void Handle(int Value) { Debug.Log(\"ConcreteStateC.Handle\"); if (Value \u003e 30) { m_Context.SetState(new ConcreteStateA(m_Context)); } } } //测试范例 void UnitTest() { Context theContext = new Context(); theContext.SetState(new ConcreteStateA(theContext)); theContext.Request(5); theContext.Request(15); theContext.Request(25); theContext.Request(35); } Context.SetState:DesignPattern_State.ConcreteStateA ConcreteStateA.Handle ConcreteStateA.Handle Context.SetState:DesignPattern_State.ConcreteStateB Context.SetState:DesignPattern_State.ConcreteStateC Context.SetState:DesignPattern_State.ConcreteStateA 除了上述三个元素，状态转换也是重要的一环。主要有两种方式： 交由Context类本身,按条件在各状态之间转换。具体实现需要在Context类里写各个状态类的转换方法。 产生Context类对象时, 马上指定初始状态给Context对象,而在后续执行过程中的状态转换则交由State对象负责,Context对象不再介入。这种方式更自然，多数人也愿意用该种方式。 ","date":"2024-12-22","objectID":"/posts/7b002b3/:2:2","tags":["书籍阅读","设计模式与游戏完美开发","设计模式","状态模式","State"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"三、使用状态模式实现游戏场景的转换\r在U3D中，游戏同一时间只会在一个场景中运行，所以我们可以将不同的场景做成不同的状态类，然后使用一个SceneStateController来控制场景（状态）转换。 具体实现 ISceneState: 场景类的接口, 定义《P级阵地》种场景转换和执行时需要调用的方法 StartState, MainMenuState, BattleState: 分别对应范例中的开始场景(StartScene), 主画面场景(MainMenuScene)及战斗场景(BattleScene),作为这些场景执行时的操作类 SceneStateController: 场景状态的拥有者(Context), 保持当前游戏场景状态, 并作为与GameLoop类互动的接口. 除此之外, 也是执行\"Unity3D场景转换\"的地方 GameLoop:: 游戏主循环类作为Unity3D与《P级阵地》的互动接口,包含了初始化游戏和定期调用更新操作 代码 //ISceneState.cs public class ISceneState { //靠状态名来区分状态 private string m_StateName = \"ISceneState\"; public string StateName { get { return m_StateName; } set { m_StateName = value; } } //持有状态机 protected SceneStateController m_Controller = null; public ISceneState(SceneStateController Controller) { m_Controller = Controller; } //状态开始的行为 public virtual void StateBegin() { } //状态结束的行为 public virtual void StateEnd() { } //状态更新的行为 public virtual void StateUpdate() { } public override string ToString() { return string.Format(\"[I_SceneState: StateName = {0}]\", StateName); } } //StartScene.cs //该类仅作为加载场景出现，所以进入该状态直接加载MainMenuScene场景 public class StartScene: ISceneState { public StartScene(SceneStateController Controller): base(Controller) { this.StateName = \"StartState\"; } public override void StateBegin() { } public override void StateUpdate() { m_Controller.SetState(new MainMenuState(m_Controller), \"MainMenuScene\"); } } //MainMenuState.cs //开始界面，只需注册一个按钮事件用于开始游戏（即转换到战斗场景BattleScene） public class MainMenuState: ISceneState { public MainMenuState(SceneStateController Controller): base(Controller) { this.StateName = \"MainMenuState\"; } public override void StateBegin() { Button tmpBtn = UITool.GetUIComponent\u003cButton\u003e(\"StartGameBtn\"); if (tempBtn != null) { tmpBtn.onClick.AddListener(()=\u003eOnStartGameBtnClick(tmpBtn)); } public void OnStartGameClick(Button theButton) { m_Controller.SetState(new BattleState(m_Controller), \"BattleScene\"); } } //BattleScene.cs //战斗场景，游戏主要玩法逻辑所在 public class BattleScene: ISceneState { public BattleScene(SceneStateController Controller): base(Controller) { this.StateName = \"BattleState\"; } public overrride void StateBegin() { PBaseDefenseGame.Instance.Initial(); } public ovrride void StateEnd() { PBaseDefenseGame.Instance.Update(); } public ovrride void StateUpdate() { InputProcess(); PBaseDefenseGame.Instance.Update(); if (PBaseDefenseGame.Instance.ThisGameIsOver()) { m_Controller.SetState(new MainMenuState(m_Controller), \"MainMenuScene\"); } } private void InputProcess() { //... } } //SceneStateController.cs // public class SceneStateController { private ISceneState m_State; private bool m_bRunBegin = false;//用于标识当前状态的开始行为函数有没有执行，没有执行则需要执行，已经执行过就不需要再执行。 public SceneStateController() { } //设置状态并且转换到对应场景 public void SetState(ISceneState State, string LoadSceneName) { m_bRunBegin = false; LoadScene(LoadSceneName); if (m_State != null) { m_State.StateEnd(); } m_State = State; } private void LoadScene(string LoadSceneName) { if (LoadSceneName == null || LoadSceneName.Length == 0) { return; } Application.LoadLevel(LoadSceneName); } public void StateUpdate() { //场景是否加载完成，如果没加载完就不执行下面的逻辑 if (Application.isLoadingLevel) { return; } if (m_state != null \u0026\u0026 m_bRunBegin == false) { m_State.StateBegin(); m_bRunBegin = true; } if (m_State != null) { m_State.StateUpdate(); } } } //GameLoop.cs //游戏主循环，通过SceneStateController控制游戏进程 public class GameLoop: MonoBehavior { SceneStateController m_SceneStateController = new SceneStateController(); void Awake() { GameObject.DontDestroyOnLoad(this.gameObject); UnityEngine.Random.seed = (int)DateTime.Now.Ticks; } void Start() { m_SceneStateController.SetState(new StartState(m_SceneStateController), \"\"); } void Update() { m_SceneStateController.StateUpdate(); } } ","date":"2024-12-22","objectID":"/posts/7b002b3/:2:3","tags":["书籍阅读","设计模式与游戏完美开发","设计模式","状态模式","State"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"四、总结\r状态模式的优点： 减少错误的发生并降低维护难度 状态执行环境单一化 项目之间可以共享场景 状态模式的缺点： 游戏状态过多时容易“状态爆炸”。 其他应用方式： 角色控制、角色AI。 游戏服务器连线状态。 关卡进行状态。 ","date":"2024-12-22","objectID":"/posts/7b002b3/:2:4","tags":["书籍阅读","设计模式与游戏完美开发","设计模式","状态模式","State"],"title":"设计模式与游戏完美开发(1)","uri":"/posts/7b002b3/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第一篇 设计模式与游戏设计\r","date":"2024-12-16","objectID":"/posts/d7a0598/:1:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第一章 游戏实践中的设计模式\r","date":"2024-12-16","objectID":"/posts/d7a0598/:2:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"一、定义及常见设计原则\r设计模式（Design Patterns or GoF）定义如下： ​ 每一种模式都在说明某种一再出现的问题，并描述解决方法的核心，之后让你能够据以变化出各种招式，来解决上万个类似的问题。 面向对象设计中常见的设计原则： 单一职责原则（SRP：Single Responsibility Principle） 即“当设计封装一个类时，该类应该只负责一件事情”。 开-闭原则（OCP：Open-Closed Principle） 即一个类应该“对扩展开放，对修改关闭”。对修改关闭即对已经完成某功能的类，不能再修改这个类的任何接口或实现。对扩展开放即对功能的增加保持开放，可以将操作方法向上提升，抽象化为接口，而功能的实现下移到子类，此时功能的增加就可以通过增加子类实现。 里氏替换原则（LSP：Liskov Substitution Principle） 即“子类必须能够替换父类”。 依赖倒置原则（DIP：Dependence Inversi Principle） 高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念。 抽象接口不应该依赖于实现，而实现应该依赖于抽象接口。 即高层模块应定义接口，再由低层模块遵循这个接口实现 接口隔离原则（ISP：Interface Segregation Principle） 即“客户端不应该被迫使用它们用不到的接口方法”。 最少知识原则（LKP：Least Knowledge Principle） 即当设计实现一个类时，这个类越少使用其他类提供的功能越好。 少用继承多用组合 尤其有的时候我们并不想完全实现父类接口的方法，此时应尽可能使用组合设计。 ","date":"2024-12-16","objectID":"/posts/d7a0598/:2:1","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"二、游戏程序设计与设计模式\r游戏程序设计面对的问题; 市场的多样性 需求的多样性 平台的多样性 技术的多样性 GoF的23种设计模式分类： 生成模式（Creational）：产生对象的过程及方式。 结构模式（Structural）：类或对象之间组合的方式。 行为模式（Behavioral）：类或对象之间互动或责任分配的方式。 可能的问题： ​ 过度设计—某些设计直到项目上市都没有被使用过。 ","date":"2024-12-16","objectID":"/posts/d7a0598/:2:2","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"第二章 游戏范例说明\r","date":"2024-12-16","objectID":"/posts/d7a0598/:3:0","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"游戏范例：P级阵地\r该书利用一个完整游戏范例说明如何应用19种设计模式，该范例《P级阵地》简介： “P级阵地是一款阵地防守游戏，任务是不让玩家的阵地被敌方单位。玩家可通过位于地图上的兵营，产生不同的兵种来防守阵地，而这些由兵营产生的玩家作战单位，会在阵地附近留守，过程之中玩家不必操控每一个作战单位，它们会自动发现来袭的敌人并将其击退。敌方单位则是定期有阵地外围不断地朝阵地中央前行，并攻击阻挡在面前的玩家单位，当有3个敌方单位抵达阵地中央，则游戏失败。” 项目地址：sttsai/PBaseDefense_Unity3D ","date":"2024-12-16","objectID":"/posts/d7a0598/:3:1","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["书籍阅读---设计模式与游戏完美开发"],"content":"GoF的设计模式范例\r除了一个应用设计模式的游戏范例，本书还提供了一个单独的设计模式练习程序包含在场景DesignPatternExample中。 ","date":"2024-12-16","objectID":"/posts/d7a0598/:3:2","tags":["书籍阅读","设计模式与游戏完美开发","设计模式"],"title":"设计模式与游戏完美开发(0)","uri":"/posts/d7a0598/"},{"categories":["博客搭建"],"content":"typora+图床实现处处可用的带图md文档\r","date":"2023-08-11","objectID":"/posts/typora+%E5%9B%BE%E5%BA%8A/:1:0","tags":["博客搭建"],"title":"Typora+图床","uri":"/posts/typora+%E5%9B%BE%E5%BA%8A/"},{"categories":["博客搭建"],"content":"Typora\r一个非常简洁好用的md文档编辑器。官方正版收费，但也不贵，不太差钱的可以直接入。或者可以使用一些“测试版”，网上一搜一大把。 官方中文站：Typora 官方中文站 (typoraio.cn) ","date":"2023-08-11","objectID":"/posts/typora+%E5%9B%BE%E5%BA%8A/:2:0","tags":["博客搭建"],"title":"Typora+图床","uri":"/posts/typora+%E5%9B%BE%E5%BA%8A/"},{"categories":["博客搭建"],"content":"图床\r图床，可以简单理解为一个网络中专门用于存储图片的空间。我们将图片上传，就会得到一个类似于网址的链接，把链接放到文档中便会显示相应的图片，且不受本地限制。 其最经典的应用就是在博客中。如果你不使用图床，那么你直接上传带有图片的md文档，图片是无法被加载的，因为你的图片还在本地。使用图床就可以解决这样的问题。 当然，也可以将你博客当中的图片一并上传至服务器，但是这种方式对于博客这种场景是不如直接使用图床方便的。 ","date":"2023-08-11","objectID":"/posts/typora+%E5%9B%BE%E5%BA%8A/:3:0","tags":["博客搭建"],"title":"Typora+图床","uri":"/posts/typora+%E5%9B%BE%E5%BA%8A/"},{"categories":["博客搭建"],"content":"在Typora中使用图床\r在typora中打开偏好设置中的-图像-，插入图片时选择-上传图片-。这里注意一些旧版本的typora是没有这个选项的，请使用较新的版本。 第一种方式： 在上传服务中选择PicGo(app)，然后点击下载app(比较慢，建议直接搜索picgo下载)，下面的路径只要找到自己安装的picgo.exe的所在路径即可。 先进入smms的官网Home - SM.MS | Dashboard (smms.app)，注册登录后点击API Token，生成Token并复制下来。 进入app，点击图床设置，有几个图床供我们选择，我这里选择的是smms（这个还算是方便好用，别的图床可以自行尝试）。点击加号，配置名随便写（最好是英文），Token就填我们上面复制的那个。备用域名要填smms.app（这步很重要，不填会出错）。 第二种方式： 在上传服务中选择picgo-core，然后点击下载，下载完成后点击打开配置文件，具体配置： { \"picBed\": { \"uploader\": \"smms\", \"smms\": { \"token\": \"你的token\" } }, \"picgoPlugins\": {} } 但是作者并没有配置成功，应该是该配置还需要加上备用域名smms.app。不太推荐该方式，因为该方式不方便管理，且下载奇慢（暂时没找到其他方式下载）。有兴趣的读者可以参照typora文档自行尝试。 点验证图片上传时可能会报错，但不用管，自行复制图片到md文档验证就行。 ","date":"2023-08-11","objectID":"/posts/typora+%E5%9B%BE%E5%BA%8A/:4:0","tags":["博客搭建"],"title":"Typora+图床","uri":"/posts/typora+%E5%9B%BE%E5%BA%8A/"},{"categories":["博客搭建"],"content":"hugo+github搭建个人博客\r非常推荐使用hugo建立自己的个人博客，安装配置都非常简单不容易出错，实乃我等小白福音 ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:1:0","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":["博客搭建"],"content":"搭建工具\r基于go语言的博客框架Hugo Git GitHub或者Gitee ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:2:0","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":["博客搭建"],"content":"搭建流程参考\r该博客搭建基本上是基于下面up的视频，hugo本身并不复杂，up也已经讲的非常好了，所以不多赘述，只贴出相应链接，以及相应的一些心得，具体安装和流程请参考下面视频。 ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:3:0","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":["博客搭建"],"content":"在mac下：\rhttps://www.bilibili.com/video/BV1q4411i7gL up主：CodeSheep 语言简练，非常易懂，整体流程清晰，建议无论是win还是mac都先看此视频。 ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:3:1","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":["博客搭建"],"content":"在win下：\rhttps://www.bilibili.com/video/BV13c411h7k7 up主：祈LHL 讲的非常全面，内容对比上面增加了部署到Gitee，更新文章，谷歌收录等。 ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:3:2","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":["博客搭建"],"content":"博客个性化\r搭建好了博客之后，就要考虑把博客真正变成自己的。通过选择主题，更改主题配置文件，甚至修改样式文件个性化自己的博客。 hugo提供了很多个性化网站主题样式模板，建议先使用NewBee（本站就是使用了该主题）。该主题由国人大佬开发，功能强大且文档非常全面细致，基本你把这个玩转其他的都可以举一反三。 NewBee主题：NewBee | Hugo Themes (gohugo.io) NewBee文档：NewBee (xioyito.top) 另外hugo的主题也切换非常容易，所以如果碰到一些配置困难的主题，稍作尝试不行就换一个主题，不要纠结，一些主题本身确实存在问题。 至此，一个简单且具有个人风格的博客就算是搭建好啦，赶快撰写文档丰富你的个人博客吧！ ","date":"2023-08-11","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/:4:0","tags":["博客搭建"],"title":"搭建博客相关","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/"},{"categories":null,"content":"\r轻易听信别人告诉你的，让禁忌阻碍你的视野，给自己定下条条框框，过约定俗成的生活 ——我把这称作二手人生。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于作者\r一个喜欢编程，游戏的小白，本博客分享一些游戏开发，编程开发路上的所见所得，所思所想。  B站：Cyber蔚蓝的个人空间-Cyber蔚蓝个人主页-哔哩哔哩视频  邮箱：azure1116@qq.com ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于博客\r博客内容主要以游戏开发方向为主，分享交流一些有趣程序、技巧、开发教程、心情和学习记录等。 博客历史\r基于 Hugo + NewBee 主题搭建博客AzureBlog并部署在GitHub Pages。 当时刚刚研二比较闲，只做打发时间，并没有想好具体记录什么内容。\r2023找完工作闲了下来，也意识到自己的很多不足（尤其在游戏开发方面），决定重新出发，深入学习并以博客记录。 并且使用新主题FixIt\r2024-12-17\r","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"}]